"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var path = require('path');

var fse = require('fs-extra');

function mergeDeep() {
  var isObject = function isObject(obj) {
    return obj && _typeof(obj) === 'object';
  };

  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }

  return objects.reduce(function (prev, obj) {
    Object.keys(obj).forEach(function (key) {
      var pVal = prev[key];
      var oVal = obj[key];

      if (Array.isArray(pVal) && Array.isArray(oVal)) {
        prev[key] = pVal.concat.apply(pVal, _toConsumableArray(oVal));
      } else if (isObject(pVal) && isObject(oVal)) {
        prev[key] = mergeDeep(pVal, oVal);
      } else {
        prev[key] = oVal;
      }
    });
    return prev;
  }, {});
}

function hasExternalizedModule(module) {
  var _module$originalSourc, _module$originalSourc2, _module$originalSourc3;

  var moduleSource = (module === null || module === void 0 ? void 0 : (_module$originalSourc = module.originalSource) === null || _module$originalSourc === void 0 ? void 0 : (_module$originalSourc2 = _module$originalSourc.call(module)) === null || _module$originalSourc2 === void 0 ? void 0 : (_module$originalSourc3 = _module$originalSourc2.source) === null || _module$originalSourc3 === void 0 ? void 0 : _module$originalSourc3.call(_module$originalSourc2)) || '';

  if ((moduleSource === null || moduleSource === void 0 ? void 0 : moduleSource.indexOf('externalize')) > -1 || false) {
    return moduleSource;
  }

  return false;
}

var emitCountMap = new Map();

var URLImportPlugin =
/*#__PURE__*/
function () {
  function URLImportPlugin(opts) {
    _classCallCheck(this, URLImportPlugin);

    if (!opts.manifestName) {
      throw new Error('URLImportPlugin: You MUST specify a manifestName in your options. Something unique. Like {manifestName: my-special-build}');
    }

    this.opts = Object.assign({
      publicPath: null,
      basePath: '',
      manifestName: 'unknown-project',
      fileName: 'importManifest.js',
      transformExtensions: /^(gz|map)$/i,
      writeToFileEmit: false,
      seed: null,
      filter: null,
      map: null,
      generate: null,
      sort: null,
      serialize: function serialize(manifest) {
        return "if(!window.entryManifest) {window.entryManifest = {}}; window.entryManifest[\"".concat(opts.manifestName, "\"] = ").concat(JSON.stringify(manifest, null, 2));
      }
    }, opts || {});
  }

  _createClass(URLImportPlugin, [{
    key: "getFileType",
    value: function getFileType(str) {
      str = str.replace(/\?.*/, '');
      var split = str.split('.');
      var ext = split.pop();

      if (this.opts.transformExtensions.test(ext)) {
        ext = "".concat(split.pop(), ".").concat(ext);
      }

      return ext;
    }
  }, {
    key: "apply",
    value: function apply(compiler) {
      var _options$optimization,
          _options$optimization2,
          _this = this;

      var options = compiler === null || compiler === void 0 ? void 0 : compiler.options;
      var chunkSplitting = (options === null || options === void 0 ? void 0 : (_options$optimization = options.optimization) === null || _options$optimization === void 0 ? void 0 : (_options$optimization2 = _options$optimization.splitChunks) === null || _options$optimization2 === void 0 ? void 0 : _options$optimization2.cacheGroups) || {};
      chunkSplitting.interleave = {
        test: function test(module) {
          if (module.resource) {
            return module.resource.includes('src') && !!hasExternalizedModule(module);
          }
        },
        name: function name(module, chunks, cacheGroupKey) {
          // dont chunk unless we are sure you can
          var moduleSource = hasExternalizedModule(module);

          if (moduleSource) {
            // module.originalSource().source((dependencyTemplates, runtimeTemplate, type = "javascript") =>{
            // return NormalModule
            //   return
            // })
            return moduleSource.match(/\/\*\s*externalize\s*:\s*(\S+)\s*\*\//)[1];
          } // returning a chunk name causes problems with mini-css popping chunks off
          // return 'main';

        },
        enforce: true
      };
      compiler.hooks.thisCompilation.tap('URLImportPlugin', function (compilation) {// TODO: throw warning when changing module ID type
        // if (options.ignoreOrder) {
        //   compilation.warnings.push(
        //     new Error(
        //       `chunk ${chunk.name || chunk.id} [${pluginName}]\n`
        //           + 'Conflicting order between:\n'
        //           + ` * ${fallbackModule.readableIdentifier(
        //             requestShortener,
        //           )}\n`
        //           + `${bestMatchDeps
        //             .map(m => ` * ${m.readableIdentifier(requestShortener)}`)
        //             .join('\n')}`,
        //     ),
        //   );
        // }
      });
      mergeDeep(options, {
        optimization: {
          splitChunks: {
            cacheGroups: chunkSplitting
          }
        }
      });
      Object.assign(options.optimization.splitChunks, {
        chunks: 'all'
      });
      Object.assign(options.optimization, {
        namedModules: true
      });
      var moduleAssets = {};
      var externalModules = {};
      var outputFolder = compiler.options.output.path;
      var outputFile = path.resolve(outputFolder, this.opts.fileName);
      var outputName = path.relative(outputFolder, outputFile);

      var moduleAsset = function moduleAsset(_ref, file) {
        var userRequest = _ref.userRequest;

        if (userRequest) {
          moduleAssets[file] = path.join(path.dirname(file), path.basename(userRequest));
        }
      };

      function getMeta(module) {
        console.log(module);
      }

      var emit = function emit(compilation, compileCallback) {
        var emitCount = emitCountMap.get(outputFile) - 1;
        emitCountMap.set(outputFile, emitCount);
        var seed = _this.opts.seed || {};
        var publicPath = _this.opts.publicPath != null ? _this.opts.publicPath : compilation.options.output.publicPath;
        var stats = compilation.getStats().toJson(); // console.log('Webpack Plugin Debugging');

        var files = compilation.chunks.reduce(function (files, chunk) {
          return chunk.files.reduce(function (files, path) {
            var name = chunk.name ? chunk.name : null;

            if (name) {
              name = "".concat(name, ".").concat(_this.getFileType(path));
            } else {
              // For nameless chunks, just map the files directly.
              name = path;
            } // console.log('stats', stats);


            if (externalModules[chunk.id]) {
              // TODO: swap forEachModle out with const of
              // const module of chunk.modulesIterable
              chunk.forEachModule(function (module) {
                if (module.dependencies) {
                  module.dependencies.forEach(function (dependency) {
                    var _dependency$getRefere, _dependency$getRefere2;

                    // console.group();
                    // console.log('dependencies foreach: dependency.module', dependency.module);
                    // console.log('dependencies foreach:  dependency.module.entry', dependency?.module?.entry?.());
                    // console.group();
                    // console.log("Level 3");
                    // console.warn("More of level 3");
                    // console.groupEnd();
                    // console.log("Back to level 2");
                    // console.groupEnd();
                    var dependencyModuleSet = (_dependency$getRefere = dependency.getReference) === null || _dependency$getRefere === void 0 ? void 0 : (_dependency$getRefere2 = _dependency$getRefere.call(dependency)) === null || _dependency$getRefere2 === void 0 ? void 0 : _dependency$getRefere2.module;
                    if (!dependencyModuleSet) return null; // console.log('getReference chunks', dependencyModuleSet);
                    // console.log('dependencyModuleSet', dependencyModuleSet);
                    // console.log('dependencyModuleSet entryModule', dependencyModuleSet?.entryModule?.());
                    // for (const module of dependencyModuleSet.chunksIterable) {
                    //   console.log('iterated dependency module', module);
                    //   console.log(module.block);
                    // }
                  });
                }
              });
            } // Webpack 4: .isOnlyInitial()
            // Webpack 3: .isInitial()
            // Webpack 1/2: .initial
            // const modules = chunk.modulesIterable;
            // let i = 0;
            // while (i < modules.length) {
            //   getMeta(modules[i]);
            //   i++;
            // }


            return files.concat({
              path: path,
              chunk: chunk,
              name: name,
              isInitial: chunk.isOnlyInitial ? chunk.isOnlyInitial() : chunk.isInitial ? chunk.isInitial() : chunk.initial,
              isChunk: true,
              isAsset: false,
              isModuleAsset: false
            });
          }, files);
        }, []); // module assets don't show up in assetsByChunkName.
        // we're getting them this way;

        files = stats.assets.reduce(function (files, asset) {
          var name = moduleAssets[asset.name];

          if (name) {
            return files.concat({
              path: asset.name,
              name: name,
              isInitial: false,
              isChunk: false,
              isAsset: true,
              isModuleAsset: true
            });
          }

          var isEntryAsset = asset.chunks.length > 0;

          if (isEntryAsset) {
            return files;
          }

          return files.concat({
            path: asset.name,
            name: asset.name,
            isInitial: false,
            isChunk: false,
            isAsset: true,
            isModuleAsset: false
          });
        }, files);
        files = files.filter(function (file) {
          // Don't add hot updates to manifest
          var isUpdateChunk = file.path.includes('hot-update'); // Don't add manifest from another instance

          var isManifest = emitCountMap.get(path.join(outputFolder, file.name)) !== undefined;
          return !isUpdateChunk && !isManifest;
        }); // Append optional basepath onto all references.
        // This allows output path to be reflected in the manifest.

        if (_this.opts.basePath) {
          files = files.map(function (file) {
            file.name = _this.opts.basePath + file.name;
            return file;
          });
        }

        if (publicPath) {
          // Similar to basePath but only affects the value (similar to how
          // output.publicPath turns require('foo/bar') into '/public/foo/bar', see
          // https://github.com/webpack/docs/wiki/configuration#outputpublicpath
          files = files.map(function (file) {
            file.path = publicPath + file.path;
            return file;
          });
        }

        files = files.map(function (file) {
          file.name = file.name.replace(/\\/g, '/');
          file.path = file.path.replace(/\\/g, '/');
          return file;
        });

        if (_this.opts.filter) {
          files = files.filter(_this.opts.filter);
        }

        if (_this.opts.map) {
          files = files.map(_this.opts.map);
        }

        if (_this.opts.sort) {
          files = files.sort(_this.opts.sort);
        }

        var manifest;

        if (_this.opts.generate) {
          manifest = _this.opts.generate(seed, files);
        } else {
          manifest = files.reduce(function (manifest, file) {
            manifest[file.name] = file.path;
            return manifest;
          }, seed);
        }

        var isLastEmit = emitCount === 0;

        if (isLastEmit) {
          var cleanedManifest = Object.entries(manifest).reduce(function (acc, _ref2) {
            var _ref3 = _slicedToArray(_ref2, 2),
                key = _ref3[0],
                asset = _ref3[1];

            if (!asset.includes('.map')) {
              return Object.assign(acc, _defineProperty({}, key, asset));
            }

            return acc;
          }, {});

          var output = _this.opts.serialize(cleanedManifest);

          compilation.assets[outputName] = {
            source: function source() {
              return output;
            },
            size: function size() {
              return output.length;
            }
          };

          if (_this.opts.writeToFileEmit) {
            fse.outputFileSync(outputFile, output);
          }
        }

        if (compiler.hooks) {
          compiler.hooks.webpackURLImportPluginAfterEmit.call(manifest);
        } else {
          compilation.applyPluginsAsync('webpack-manifest-plugin-after-emit', manifest, compileCallback);
        }
      };

      function beforeRun(compiler, callback) {
        var emitCount = emitCountMap.get(outputFile) || 0;
        emitCountMap.set(outputFile, emitCount + 1);

        if (callback) {
          callback();
        }
      }

      if (compiler.hooks) {
        var _require = require('tapable'),
            SyncWaterfallHook = _require.SyncWaterfallHook;

        var pluginOptions = {
          name: 'URLImportPlugin',
          stage: Infinity
        };
        compiler.hooks.webpackURLImportPluginAfterEmit = new SyncWaterfallHook(['manifest']);
        compiler.hooks.compilation.tap('URLImportPlugin', function (compilation) {
          compilation.hooks.beforeModuleIds.tap('URLImportPlugin', function (modules) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var _module$originalSourc4, _module$originalSourc5, _module$originalSourc6;

                var _module = _step.value;
                var moduleSource = (_module === null || _module === void 0 ? void 0 : (_module$originalSourc4 = _module.originalSource) === null || _module$originalSourc4 === void 0 ? void 0 : (_module$originalSourc5 = (_module$originalSourc6 = _module$originalSourc4.call(_module)).source) === null || _module$originalSourc5 === void 0 ? void 0 : _module$originalSourc5.call(_module$originalSourc6)) || '';

                if ((moduleSource === null || moduleSource === void 0 ? void 0 : moduleSource.indexOf('externalize')) > -1 || false) {
                  _module.buildMeta = mergeDeep(_module.buildMeta, {
                    isExternalized: true
                  });

                  try {
                    // look at refactoring this to use buildMeta not mutate id
                    _module.id = moduleSource.match(/\/\*\s*externalize\s*:\s*(\S+)\s*\*\//)[1];
                  } catch (error) {}

                  externalModules[_module.id] = {};
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          });
        });
        compiler.hooks.compilation.tap(pluginOptions, function (_ref4) {
          var hooks = _ref4.hooks;
          hooks.moduleAsset.tap(pluginOptions, moduleAsset);
        });
        compiler.hooks.emit.tap(pluginOptions, emit);
        compiler.hooks.run.tap(pluginOptions, beforeRun);
        compiler.hooks.watchRun.tap(pluginOptions, beforeRun);
      } else {
        compiler.plugin('compilation', function (compilation) {
          compilation.plugin('module-asset', moduleAsset);
        });
        compiler.plugin('emit', emit);
        compiler.plugin('before-run', beforeRun);
        compiler.plugin('watch-run', beforeRun);
      }
    }
  }]);

  return URLImportPlugin;
}();

module.exports = URLImportPlugin;